1,"Which of these best describes an array?|a) A data structure that shows a hierarchical behavior|b) Container of objects of similar types|c) Arrays are immutable once initialised|d) Array is not a data structure","b","Array contains elements only of the same type.",10,
2,"How do you initialize an array in C?|a) int arr[3] = (1,2,3);|b) int arr(3) = {1,2,3};|c) int arr[3] = {1,2,3};|d) int arr(3) = (1,2,3);","c","This is the syntax to initialize an array in C.",10,
3,"How do you instantiate an array in Java?|a) int arr[] = new int(3);|b) int arr[];|c) int arr[] = new int[3];|d) int arr() = new int(3);","c","Note that int arr[]; is declaration whereas int arr[] = new int[3]; is to instantiate an array.",10,
4,"Which of the following is the correct way to declare a multidimensional array in Java?|a) int[] arr;|b) int arr[[]];|c) int[][]arr;|d) int[[]] arr;","c","The syntax to declare multidimensional array in java is either int[][] arr; or int arr[][].",10,
7,"When does the ArrayIndexOutOfBoundsException occur?|a) Compile-time|b) Run-time|c) Not an error|d) Not an exception at all","b","ArrayIndexOutOfBoundsException is a run-time exception and the compilation is error-free.",10,
8,"Which of the following concepts make extensive use of arrays?|a) Binary trees|b) Scheduling of processes|c) Caching|d) Spatial locality","d","Whenever a particular memory location is referred to, it is likely that the locations nearby are also referred, arrays are stored as contiguous blocks in memory, so if you want to access array elements, spatial locality makes it to access quickly.",10,
9,"Assuming int is of 4bytes, what is the size of int arr[15];?|a) 15|b) 19|c) 11|d) 60","d","Since there are 15 int elements and each int is of 4bytes, we get 15*4 = 60bytes.",10,
10,"Process of removing an element from stack is called __________|a) Create|b) Push|c) Evaluation|d) Pop","d","Elements in the stack are removed using pop operation. Pop operation removes the top most element in the stack i.e. last entered element.",10,
11,"Pushing an element into stack already having five elements and stack size of 5, then stack becomes ___________|a) Overflow|b) Crash|c) Underflow|d) User flow","a","The stack is filled with 5 elements and pushing one more element causes a stack overflow. This results in overwriting memory, code and loss of unsaved work on the computer.",10,
12,"Which of the following is not the application of stack?|a) A parentheses balancing program|b) Tracking of local variables at run time|c) Compiler Syntax Analyzer|d) Data Transfer between two asynchronous process","d","Data transfer between the two asynchronous process uses the queue data structure for synchronisation. The rest are all stack applications.",10,
13,"Consider the usual algorithm for determining whether a sequence of parentheses is balanced. The maximum number of parentheses that appear on the stack AT ANY ONE TIME when the algorithm analyzes: (()(())(()))?|a) 1|b) 2|c) 3|d) 4 or more","c","In the entire parenthesis balancing method when the incoming token is a left parenthesis it is pushed into stack. A right parenthesis makes pop operation to delete the elements in stack till we get left parenthesis as top most element. 3 elements are there in stack before right parentheses comes. Therefore, maximum number of elements in stack at run time is 3.",10,
14,"Consider the usual algorithm for determining whether a sequence of parentheses is balanced. Suppose that you run the algorithm on a sequence that contains 2 left parentheses and 3 right parentheses (in some order). The maximum number of parentheses that appear on the stack AT ANY ONE TIME during the computation?|a) 1|b) 2|c) 3|d) 4 or more","b","In the entire parenthesis balancing method when the incoming token is a left parenthesis it is pushed into stack. A right parenthesis makes pop operation to delete the elements in stack till we get left parenthesis as top most element. 2 left parenthesis are pushed whereas one right parenthesis removes one of left parenthesis. 2 elements are there before right parenthesis which is the maximum number of elements in stack at run time.",10,
15,"Here is an infix expression: 4 + 3*(6*3-12). Suppose that we are using the usual stack algorithm to convert the expression from infix to postfix notation. The maximum number of symbols that will appear on the stack AT ONE TIME during the conversion of this expression?|a) 1|b) 2|c) 3|d) 4","d","When we perform the conversion from infix to postfix expression +, *, (, * symbols are placed inside the stack. A maximum of 4 symbols are identified during the entire conversion.",10,
16,"The data structure required to check whether an expression contains a balanced parenthesis is?|a) Stack|b) Queue|c) Array|d) Tree","a","The stack is a simple data structure in which elements are added and removed based on the LIFO principle. Open parenthesis is pushed into the stack and a closed parenthesis pops out elements till the top element of the stack is its corresponding open parenthesis. If the stack is empty, parenthesis is balanced otherwise it is unbalanced.",10,
17,"What data structure would you mostly likely see in non recursive implementation of a recursive algorithm?|a) Linked List|b) Stack|c) Queue|d) Tree","b","In recursive algorithms, the order in which the recursive process comes back is the reverse of the order in which it goes forward during execution. The compiler uses the stack data structure to implement recursion. In the forwarding phase, the values of local variables, parameters and the return address are pushed into the stack at each recursion level. In the backing-out phase, the stacked address is popped and used to execute the rest of the code.",10,
18,"The process of accessing data stored in a serial access memory is similar to manipulating data on a ________|a) Heap|b) Binary Tree|c) Array|d) Stack","d","In serial access memory data records are stored one after the other in which they are created and are accessed sequentially. In stack data structure, elements are accessed sequentially. Stack data structure resembles the serial access memory.",10,
19,"The postfix form of A*B+C/D is?|a) *AB/CD+|b) AB*CD/+|c) A*BC+/D|d) ABCD+/*","b","Infix expression is (A*B)+(C/D) AB*+(C/D) AB*CD/+. Thus postfix expression is AB*CD/+.",10,
20,"Which data structure is needed to convert infix notation to postfix notation?|a) Branch|b) Tree|c) Queue|d) Stack","d","The Stack data structure is used to convert infix expression to postfix expression. The purpose of stack is to reverse the order of the operators in the expression. It also serves as a storage structure, as no operator can be printed until both of its operands have appeared.",10,
21,"The prefix form of A-B/ (C * D ^ E) is?|a) -/*^ACBDE|b) -ABCD*^DE|c) -A/B*C^DE|d) -A/BC*^DE","c","Infix Expression is (A-B)/(C*D^E) (-A/B)(C*D^E) -A/B*C^DE. Thus prefix expression is -A/B*C^DE.",10,
22,"What is the result of the following operation? Top (Push (S, X))?|a) X|b) X+S|c) S|d) XS","a","The function Push(S,X) pushes the value X in the stack S. Top() function gives the value which entered last. X entered into stack S at last.",10,
23,"Which data structure is used for implementing recursion?|a) Queue|b) Stack|c) Array|d) List","b","Stacks are used for the implementation of Recursion.",10,
24,"Which of the following statement(s) about stack data structure is/are NOT correct?|a) Linked List are used for implementing Stacks|b) Top of the Stack always contain the new node|c) Stack is the FIFO data structure|d) Null link is present in the last node at the bottom of the stack","c","Stack follows LIFO.",10,
26,"Which of the following is not an inherent application of stack?|a) Reversing a string|b) Evaluation of postfix expression|c) Implementation of recursion|d) Job scheduling","d","Job Scheduling is not performed using stacks.",10,
27,"The type of expression in which operator succeeds its operands is?|a) Infix Expression|b) Prefix Expression|c) Postfix Expression|d) Both Prefix and Postfix Expressions","c","The expression in which operator succeeds its operands is called postfix expression. The expression in which operator precedes the operands is called prefix expression. If an operator is present between two operands, then it is called infix expressions.",10,
28,"The data structure required for Breadth First Traversal on a graph is?|a) Stack|b) Array|c) Queue|d) Tree","c","In Breadth First Search Traversal, BFS, starting vertex is first taken and adjacent vertices which are unvisited are also taken. Again, the first vertex which was added as an unvisited adjacent vertex list will be considered to add further unvisited vertices of the graph. To get the first unvisited vertex we need to follows First In First Out principle. Queue uses FIFO principle.",10,
29,"A queue follows __________|a) FIFO (First In First Out) principle|b) LIFO (Last In First Out) principle|c) Ordered array|d) Linear tree","a","Element first added in queue will be deleted first which is FIFO principle.",10,
30,"Circular Queue is also known as ________|a) Ring Buffer|b) Square Buffer|c) Rectangle Buffer|d) Curve Buffer","a","Circular Queue is also called as Ring Buffer. Circular Queue is a linear data structure in which last position is connected back to the first position to make a circle. It forms a ring structure.",10,
31,"A data structure in which elements can be inserted or deleted at/from both ends but not in the middle is?|a) Queue|b) Circular queue|c) Dequeue|d) Priority queue","c","In dequeuer, we can insert or delete elements from both the ends. In queue, we will follow first in first out principle for insertion and deletion of elements. Element with least priority will be deleted in a priority queue.",10,
32,"Queues serve major role in ______________|a) Simulation of recursion|b) Simulation of arbitrary linked list|c) Simulation of limited resource allocation|d) Simulation of heap sort","c","Simulation of recursion uses stack data structure. Simulation of arbitrary linked lists uses linked lists. Simulation of resource allocation uses queue as first entered data needs to be given first priority during resource allocation. Simulation of heap sort uses heap data structure.",10,
33,"Which of the following is not the type of queue?|a) Ordinary queue|b) Single ended queue|c) Circular queue|d) Priority queue","b","Queue always has two ends. So, single ended queue is not the type of queue.",10,
34,"Consider an implementation of unsorted singly linked list. Suppose it has its representation with a head pointer only. Given the representation, which of the following operation can be implemented in O(1) time?|i) Insertion at the front of the linked list|ii) Insertion at the end of the linked list|iii) Deletion of the front node of the linked list|iv) Deletion of the last node of the linked list|a) I and II|b) I and III|c) I, II and III|d) I, II and IV","b","We know the head node in the given linked list. Insertion and deletion of elements at the front of the linked list completes in O (1) time whereas for insertion and deletion at the last node requires to traverse through every node in the linked list. Suppose there are n elements in a linked list, we need to traverse through each node. Hence time complexity becomes O(n).",10,
35,"In linked list each node contains a minimum of two fields. One field is data field to store the data second field is?|a) Pointer to character|b) Pointer to integer|c) Pointer to node|d) Node","c","Each node in a linked list contains data and a pointer (reference) to the next node. Second field contains pointer to node.",10,
36,"What would be the asymptotic time complexity to add a node at the end of singly linked list, if the pointer is initially pointing to the head of the list?|a) O(1)|b) O(n)|c) (n)|d) (1)","c","In case of a linked list having n elements, we need to travel through every node of the list to add the element at the end of the list. Thus asymptotic time complexity is (n).",10,
37,"What would be the asymptotic time complexity to insert an element at the front of the linked list (head is known)?|a) O(1)|b) O(n)|c) O(n2)|d) O(n3)","a","To add an element at the front of the linked list, we will create a new node which holds the data to be added to the linked list and pointer which points to head position in the linked list. The entire thing happens within O (1) time. Thus the asymptotic time complexity is O (1).",10,
38,"What would be the asymptotic time complexity to find an element in the linked list?|a) O(1)|b) O(n)|c) O(n2)|d) O(n4)","b","If the required element is in the last position, we need to traverse the entire linked list. This will take O (n) time to search the element.",10,
39,"What would be the asymptotic time complexity to insert an element at the second position in the linked list?|a) O(1)|b) O(n)|c) O(n2)|d) O(n3)","a","A new node is created with the required element. The pointer of the new node points the node to which the head node of the linked list is also pointing. The head node pointer is changed and it points to the new node which we created earlier. The entire process completes in O (1) time. Thus the asymptotic time complexity to insert an element in the second position of the linked list is O (1).",10,
40,"The concatenation of two lists can be performed in O(1) time. Which of the following variation of the linked list can be used?|a) Singly linked list|b) Doubly linked list|c) Circular doubly linked list|d) Array implementation of list","c","We can easily concatenate two lists in O (1) time using singly or doubly linked list, provided that we have a pointer to the last node at least one of the lists. But in case of circular doubly linked lists, we will break the link in both the lists and hook them together. Thus circular doubly linked list concatenates two lists in O (1) time.",10,
41,"Consider the following definition in c programming language. struct node { } typedef struct node NODE; NODE *ptr; Which of the following c code is used to create new node? a) ptr = (NODE*)malloc(sizeof(NODE)); b) ptr = (NODE*)malloc(NODE); c) ptr = (NODE*)malloc(sizeof(NODE*)); d) ptr = (NODE)malloc(sizeof(NODE));","a","As it represents the right way to create a node.",10,
42,"Linked lists are not suitable for the implementation of ___________ a) Insertion sort b) Radix sort c) Polynomial manipulation d) Binary search","d","It cannot be implemented using linked lists.",10,
43,"Linked list is considered as an example of ___________ type of memory allocation. a) Dynamic b) Static c) Compile time d) Heap","a","As memory is allocated at the run time.",10,
44,"In Linked List implementation, a node carries information regarding ___________ a) Data b) Link c) Data and Link d) Node","b","A linked list is a collection of objects linked together by references from an object to another object. By convention these objects are names as nodes. Linked list consists of nodes where each node contains one or more data fields and a reference(link) to the next node.",10,
45,"Linked list data structure offers considerable saving in _____________ a) Computational Time b) Space Utilization c) Space Utilization and Computational Time d) Speed Utilization","c","Linked lists saves both space and time.",10,
46,"Which of the following points is/are not true about Linked List data structure when it is compared with an array? a) Arrays have better cache locality that can make them better in terms of performance b) It is easy to insert and delete elements in Linked List c) Random access is not allowed in a typical implementation of Linked Lists d) Access of elements in linked list takes less time than compared to arrays","d","To access an element in a linked list, we need to traverse every element until we reach the desired element. This will take more time than arrays as arrays provide random access to its elements.",10,
47,"What does the following function do for a given Linked List with first node as head? void fun1(struct node* head) { } a) Prints all nodes of linked lists b) Prints all nodes of linked list in reverse order c) Prints alternate nodes of Linked List d) Prints alternate nodes in reverse order","b","fun1() prints the given Linked List in reverse manner. For Linked List 1->2->3->4->5, fun1() prints 5->4->3->2->1.",10,
48,"Which of the following sorting algorithms can be used to sort a random linked list with minimum time complexity? a) Insertion Sort b) Quick Sort c) Heap Sort d) Merge Sort","d","Both Merge sort and Insertion sort can be used for linked lists. The slow random-access performance of a linked list makes other algorithms (such as quicksort) perform poorly, and others (such as heapsort) completely impossible. Since worst case time complexity of Merge Sort is O(nLogn) and Insertion sort is O(n2), merge sort is preferred.",10,
49,"What is the time complexity of inserting at the end in dynamic arrays? a) O(1) b) O(n) c) O(logn) d) Either O(1) or O(n)","d","Depending on whether the array is full or not, the complexity in dynamic array varies. If you try to insert into an array that is not full, then the element is simply stored at the end, this takes O(1) time. If you try to insert into an array which is full, first you will have to allocate an array with double the size of the current array and then copy all the elements into it and finally insert the new element, this takes O(n) time.",10,
50,"What is the time complexity to count the number of elements in the linked list? a) O(1) b) O(n) c) O(logn) d) O(n2)","b","To count the number of elements, you have to traverse through the entire list, hence complexity is O(n).",10,
52,"What is the time complexity of pop() operation when the stack is implemented using an array?|a) O(1)|b) O(n)|c) O(logn)|d) O(nlogn)","a","pop() accesses only one end of the structure, and hence constant time.",10,
53,"Which of the following array position will be occupied by a new element being pushed for a stack of size N elements (capacity of stack > N)?|a) S[N-1]|b) S[N]|c) S[1]|d) S[0]","b","Elements are pushed at the end, hence N.",10,
54,"What happens when you pop from an empty stack while implementing using the Stack ADT in Java?|a) Undefined error|b) Compiler displays a warning|c) EmptyStackException is thrown|d) NoStackException is thrown","c","The Stack ADT throws an EmptyStackException if the stack is empty and a pop() operation is tried on it.",10,
55,"Array implementation of Stack is not dynamic, which of the following statements supports this argument?|a) space allocation for array is fixed and cannot be changed during run-time|b) user unable to give the input for stack operations|c) a runtime exception halts execution|d) improper program compilation","a","You cannot modify the size of an array once the memory has been allocated, adding fewer elements than the array size would cause wastage of space, and adding more elements than the array size at run time would cause Stack Overflow.",10,
56,"Which of the following statements are not correct with respect to Singly Linked List (SLL) and Doubly Linked List (DLL)?|a) Complexity of Insertion and Deletion at known position is O(n) in SLL and O(1) in DLL|b) SLL uses lesser memory per node than DLL|c) DLL has more searching power than SLL|d) Number of node fields in SLL is more than DLL","d","To insert and delete at known positions requires complete traversal of the list in worst case in SLL, SLL consists of an item and a node field, while DLL has an item and two node fields, hence SLL occupies lesser memory, DLL can be traversed both ways (left and right), while SLL can traverse in only one direction, hence more searching power of DLL. Node fields in SLL is 2 (data and address of next node) whereas in DLL is 3 (data, address to next node, address to previous node).",10,
57,"Which of the following data structures can be used for parentheses matching?|a) n-ary tree|b) queue|c) priority queue|d) stack","d","For every opening brace, push it into the stack, and for every closing brace, pop it off the stack. Do not take action for any other character. In the end, if the stack is empty, then the input has balanced parentheses.",10,
58,"What is the time complexity of enqueue operation?|a) O(logn)|b) O(nlogn)|c) O(n)|d) O(1)","d","Enqueue operation is at the rear end, it takes O(1) time to insert a new item into the queue.",10,
59,"What is the need for a circular queue?|a) effective usage of memory|b) easier computations|c) to delete elements based on priority|d) implement LIFO principle in queues","a","In a linear queue, dequeue operation causes the starting elements of the array to be empty, and there is no way you can use that space, while in a circular queue, you can effectively use that space. Priority queue is used to delete the elements based on their priority. Higher priority elements will be deleted first whereas lower priority elements will be deleted next. Queue data structure always follows FIFO principle.",10,
60,"In linked list implementation of a queue, where does a new element be inserted?|a) At the head of link list|b) At the centre position in the link list|c) At the tail of the link list|d) At any position in the linked list","c","Since queue follows FIFO so new element inserted at last.",10,
61,"In linked list implementation of a queue, front and rear pointers are tracked. Which of these pointers will change during an insertion into a NONEMPTY queue?|a) Only front pointer|b) Only rear pointer|c) Both front and rear pointer|d) No pointer will be changed","b","Since queue follows FIFO so new element inserted at last.",10,
62,"In linked list implementation of a queue, front and rear pointers are tracked. Which of these pointers will change during an insertion into EMPTY queue?|a) Only front pointer|b) Only rear pointer|c) Both front and rear pointer|d) No pointer will be changed","c","Since its the starting of queue, so both values are changed.",10,
63,"In case of insertion into a linked queue, a node borrowed from the __________ list is inserted in the queue.|a) AVAIL|b) FRONT|c) REAR|d) NULL","a","All the nodes are collected in AVAIL list.",10,
64,"In linked list implementation of a queue, from where is the item deleted?|a) At the head of link list|b) At the centre position in the link list|c) At the tail of the link list|d) Node before the tail","a","Since queue follows FIFO so new element deleted from first.",10,
65,"In linked list implementation of a queue, the important condition for a queue to be empty is?|a) FRONT is null|b) REAR is null|c) LINK is empty|d) FRONT==REAR-1","a","Because front represents the deleted nodes.",10,
66,"The essential condition which is checked before insertion in a linked queue is?|a) Underflow|b) Overflow|c) Front value|d) Rear value","b","To check whether there is space in the queue or not.",10,
67,"The essential condition which is checked before deletion in a linked queue is?|a) Underflow|b) Overflow|c) Front value|d) Rear value","a","To check whether there is element in the list or not.",10,
68,"Which of the following is true about linked list implementation of queue?|a) In push operation, if new nodes are inserted at the beginning of linked list, then in pop operation, nodes must be removed from end|b) In push operation, if new nodes are inserted at the beginning, then in pop operation, nodes must be removed from the beginning|c) In push operation, if new nodes are inserted at the end, then in pop operation, nodes must be removed from end|d) In push operation, if new nodes are inserted at the end, then in pop operation, nodes must be removed from beginning","a","It can be done by both the methods.",10,
69,"Which of the following is not an application of priority queue?|a) Huffman codes|b) Interrupt handling in operating system|c) Undo operation in text editors|d) Bayesian spam filter","c","Undo operation is achieved using a stack.",10,
70,"What is the functionality of the following piece of code?|public Object delete_key() |{|{|System.out.println(""Q is empty"");|System.exit(0);|}|{|Node cur = head.getNext();|Node dup = cur.getNext();|Object e = cur.getEle();|}|}|a) Delete the second element in the list|b) Return but not delete the second element in the list|c) Delete the first element in the list|d) Return but not delete the first element in the list","c","A pointer is made to point at the first element in the list and one more to point to the second element, pointer manipulations are done such that the first element is no longer being pointed by any other pointer, its value is returned.",10,
71,"What is not a disadvantage of priority scheduling in operating systems?|a) A low priority process might have to wait indefinitely for the CPU|b) If the system crashes, the low priority systems may be lost permanently|c) Interrupt handling|d) Indefinite blocking","c","The lower priority process should wait until the CPU completes the processing higher priority process. Interrupt handling is an advantage as interrupts should be given more priority than tasks at hand so that interrupt can be serviced to produce desired results.",10,
72,"Which of the following is not an advantage of a priority queue?|a) Easy to implement|b) Processes with different priority can be efficiently handled|c) Applications with differing requirements|d) Easy to delete elements in any case","d","In worst case, the entire queue has to be searched for the element having the highest priority. This will take more time than usual. So deletion of elements is not an advantage.",10,
73,"Consider you have an array of some random size. You need to perform dequeue operation. You can perform it using stack operation (push and pop) or using queue operations itself (enQueue and Dequeue). The output is guaranteed to be same. Find some differences?|a) They will have different time complexities|b) The memory used will not be different|c) There are chances that output might be different|d) No differences","a","To perform operations such as Dequeue using stack operation you need to empty all the elements from the current stack and push it into the next stack, resulting in a O(number of elements) complexity whereas the time complexity of dequeue operation itself is O(1). And there is a need of a extra stack. Therefore more memory is needed.",10,
74,"Why is implementation of stack operations on queues not feasible for a large dataset (Asssume the number of elements in the stack to be n)?|a) Because of its time complexity O(n)|b) Because of its time complexity O(log(n))|c) Extra memory is not required|d) There are no problems","a","To perform Queue operations such as enQueue and deQueue there is a need of emptying all the elements of a current stack and pushing elements into the next stack and vice versa. Therfore it has a time complexity of O(n) and the need of extra stack as well, may not be feasible for a large dataset.",10,
75,"Consider yourself to be in a planet where the computational power of chips to be slow. You have an array of size 10.You want to perform enqueue some element into this array. But you can perform only push and pop operations .Push and pop operation both take 1 sec respectively. The total time required to perform enQueue operation is?|a) 20|b) 40|c) 42|d) 43","d","First you have to empty all the elements of the current stack into the temporary stack, push the required element and empty the elements of the temporary stack into the original stack. Therfore taking 10+10+1+11+11= 43 seconds.",10,
76,"You have two jars, one jar which has 10 rings and the other has none. They are placed one above the other. You want to remove the last ring in the jar. And the second jar is weak and cannot be used to store rings for a long time.|a) Empty the first jar by removing it one by one from the first jar and placing it into the second jar|b) Empty the first jar by removing it one by one from the first jar and placing it into the second jar and empty the second jar by placing all the rings into the first jar one by one|c) There exists no possible way to do this|d) Break the jar and remove the last one","b","This is similar to performing dequeue operation using push and pop only. Elements in the first jar are taken out and placed in the second jar. After removing the last element from the first jar, remove all the elements in the second jar and place them in the first jar.",10,
77,"Given only a single array of size 10 and no other memory is available. Which of the following operation is not feasible to implement (Given only push and pop operation)?|a) Push|b) Pop|c) Enqueue|d) Returntop","c","To perform Enqueue using just push and pop operations, there is a need of another array of same size. But as there is no extra available memeory, the given operation is not feasible.",10,
78,"How many passes does the evaluation of infix expression algorithm makes through the input?|a) One|b) Two|c) Three|d) Four","a","Evaluation of infix expression algorithm is linear and makes only one pass through the input.",10,
79,"Identify the infix expression from the list of options given below.|a) a/b+(c-d)|b) abc*+d+ab+cd+*ce-f-|c) ab-c-|d) +ab","a","a/b+(c-d) is an infix expression since the operators are placed in between the operands.",10,
80,"Which of the following statement is incorrect with respect to evaluation of infix expression algorithm?|a) Operand is pushed on to the stack|b) If the precedence of operator is higher, pop two operands and evaluate|c) If the precedence of operator is lower, pop two operands and evaluate|d) The result is pushed on to the operand stack","b","If the precedence of the operator is higher than the stack operator, then it is pushed on to the stack operator.",10,
81,"Evaluation of infix expression is done based on precedence of operators.|a) True|b) False","a","During evaluation of infix expression, the operators with higher precedence are evaluated first, followed by operators with lower precedence.",10,
82,"Of the following choices, which operator has the lowest precedence?|a) ^|b) +|c) /|d) #","d","The operator with the lowest precedence is #, preceded by +, / and then ^.",10,
83,"The system throws an error if parentheses are encountered in an infix expression evaluation algorithm.|a) True|b) False","b","The algorithm holds good for infix expression with parentheses. The system does not throw error.",10,
84,"Evaluate the following and choose the correct answer.|a/b+c*d where a=4, b=2, c=2, d=1.|a) 1|b) 4|c) 5|d) 2","b","* and / have higher priority. Hence, they are evaluated first. Then, + is evaluated. Hence, 2+2=4.",10,
85,"Evaluate the following statement using infix evaluation algorithm and choose the correct answer.|4*2+3-5/5|a) 10|b) 11|c) 16|d) 12","a","4*2 and 5/5 are evaluated first and then, 8+3-1 is evaluated and the result is obtained as 10.",10,
86,"Using the evaluation of infix expression, evaluate a^b+c  and choose the correct answer. (a=2, b=2, c=2)|a) 12|b) 8|c) 10|d) 6","d","^ has the highest precedence. Hence, 2^2 is evaluated and then 4+2 gives 6.",10,
87,"Evaluate the following infix expression using algorithm and choose the correct answer.|a+b*c-d/e^f  where a=1, b=2, c=3, d=4, e=2, f=2.|a) 6|b) 8|c) 9|d) 7","a","^ has the highest order of precedence. Hence, 2^2 is evaluated first, and then, 2*3 and 4/4 are evaluated. Therefore, 1+6-1=6.",10,
89,"While evaluating a prefix expression, the string is read from?|a) left to right|b) right to left|c) center to right|d) center to left to right","b","The string is read from right to left because a prefix string has operands to its right side.",10,
90,"The associativity of an exponentiation operator ^ is right side.|a) True|b) False","a","The associativity of ^ is right side while the rest of the operators like +,-,*,/ has its associativity to its left.",10,
92,"What determines the order of evaluation of a prefix expression?|a) precedence and associativity|b) precedence only|c) associativity only|d) depends on the parser","a","Precedence is a very important factor in determining the order of evaluation. If two operators have the same precedence, associativity comes into action.",10,
93,"Find the output of the following prefix expression|*+2-2 1/-4 2+-5 3 1|a) 2|b) 12|c) 10|d) 4","a","The given prefix expression is evaluated using two stacks and the value is given by (2+2-1)*(4-2)/(5-3+1)= 2.",10,
94,"Using the evaluation of prefix algorithm, evaluate +-9 2 7.|a) 10|b) 4|c) 17|d) 14","d","Using the evaluation of prefix algorithm, +-9 2 7 is evaluated as 9-2+7=14.",10,
95,"If -*+abcd = 11, find a, b, c, d using evaluation of prefix algorithm.|a) a=2, b=3, c=5, d=4|b) a=1, b=2, c=5, d=4|c) a=5, b=4, c=7,d=5|d) a=1, b=2, c=3, d=4","b","The given prefix expression is evaluated as ((1+2)*5)-4 =11 while a=1, b=2, c=5, d=4.",10,
96,"Which of the following is an example for a postfix expression?|a) a*b(c+d)|b) abc*+de-+|c) +ab|d) a+b-c","b","abc*+de-+ is a postfix expression. +ab is a prefix expression and others are infix expressions.",10,
97,"Reverse Polish Notation is the reverse of a Polish Notation|a) True|b) False","b","Reverse Polish Notation is not the reverse of a polish notation. Though both NPN and RPN read the expression from left to right, they follow different strategies.",10,
98,"What is the time complexity of evaluation of postfix expression algorithm?|a) O (N)|b) O (N log N)|c) O (N2)|d) O (M log N)","a","The time complexity of evaluation of infix, prefix and postfix expressions is O (N).",10,
99,"In Postfix expressions, the operators come after the operands.|a) True|b) False","a","In postfix expressions, the operators follow operands. In prefix expressions, the operands follow operators.",10,
100,"Which of the following is not an application of stack?|a)  evaluation of postfix expression|b)  conversion of infix to postfix expression|c)  balancing symbols|d)  line at ticket counter","d","Line at ticket counter is an application of queue whereas conversion of infix to postfix expression, balancing symbols, line at ticket counter are stack applications.",10,
101,"While evaluating a postfix expression, when an operator is encountered, what is the correct operation to be performed?|a) push it directly on to the stack|b) pop 2 operands, evaluate them and push the result on to the stack|c) pop the entire stack|d) ignore the operator","b","When an operator is encountered, the first two operands are popped from the stack, they are evaluated and the result is pushed into the stack.",10,
102,"Which of the following statement is incorrect?|a) Postfix operators use value to their right|b) Postfix operators use value to their left|c) Prefix operators use value to their right|d) In postfix expression, operands are followed by operators","a","All prefix operators use values to their right and all postfix operators use values to their left.",10,
103,"What is the result of the given postfix expression?  abc*+ where a=1, b=2, c=3.|a) 4|b) 5|c) 6|d) 7","d","The infix expression is a+b*c. Evaluating it, we get 1+2*3=7.",10,
104,"What is the result of the following postfix expression?|a) 16|b) 12|c) 14|d) 10","a","The infix expression is a*b+c*d. Evaluating it, we get, 2*2+3*4=16.",10,
105,"Evaluate the postfix expression ab + cd/- where a=5, b=4, c=9, d=3.|a) 23|b) 15|c) 6|d) 10","c","The infix expression is (a+b)-c/d. Evaluating it, (5+4)-9/3 gives 6.",10,
106,"Evaluate and write the result for the following postfix expression|a) 61|b) 59|c) 60|d) 55","b","The infix expression is a+b*c+(d*e+f)*g. Evaluating it, 1+2*3+(4*5+6)*2 gives 59.",10,
107,"What would be the Prefix notation for the given equation?|A+(B*C)|a) +A*CB|b) *B+AC|c) +A*BC|d) *A+CB","c","Reverse the equation or scan the equation from right to left. Apply the infix-postfix algorithm. The equation inside the bracket evaluates to CB* and outside the bracket evaluates to A+ therefore getting CB*A+. Reversing this and we get +A*BC.",10,
108,"What would be the Prefix notation for the given equation?|(A*B)+(C*D)|a) +*AB*CD|b) *+AB*CD|c) **AB+CD|d) +*BA*CD","a","Reverse the equation or scan the equation from right to left. Apply the infix-postfix algorithm. The equation inside the brackets evaluate to DC* and BA* respectively giving us DC*BA*+ in the end. Reversing this we get the +*AB*CD.",10,
109,"What would be the Prefix notation for the given equation?|A+B*C^D|a) +A*B^CD|b) +A^B*CD|c) *A+B^CD|d) ^A*B+CD","a","Reverse the equation or scan the equation from right to left. Apply the infix-prefix algorithm. The preference order in ascending order are as follows +*^. Operators are pushed into the stack and popped if its preference is greater than the one which is getting pushed. In the end all operators are popped. The equation evaluates to DC^B*A+. Reversing this we get our following answer.",10,
110,"Out of the following operators (^, *, +, &, $), the one having highest priority is _________|a) +|b) $|c) ^|d) &","c","According to the algorithm (infix-prefix), it follows that the exponentiation will have the highest priority.",10,
111,"What would be the Prefix notation for the given equation?|A^B^C^D|a) ^^^ABCD|b) ^A^B^CD|c) ABCD^^^|d) AB^C^D","a","Reverse the equation or scan the equation from right to left. Apply the infix-prefix algorithm. Here we have to remember that the exponentiation has order of associativity from right to left. Therefore the stack goes on pushing ^. Therefore resulting in ^^^ABCD.",10,
112,"What would be the Prefix notation for the given equation?|a+b-c/d&e|f|a) |&-+ab/cdef|b) &|-+ab/cdef|c) |&-ab+/cdef|d) |&-+/abcdef","a","Reverse the equation or scan the equation from right to left. Apply the infix-prefix algorithm. The preference order in ascending order are as follows |&+*/.",10,
113,"Which of the following is an infix expression?|a) (a+b)*(c+d)|b) ab+c*|c) +ab|d) abc+*","a","(a+b)*(c+d) is an infix expression. +ab is a prefix expression and ab+c* is a postfix expression.",10,
114,"What is the time complexity of an infix to postfix conversion algorithm?|a) O(N log N)|b) O(N)|c) O(N2)|d) O(M log N)","b","The time complexity of an infix to postfix expression conversion algorithm is mathematically found to be O(N).",10,
115,"What is the postfix expression for the corresponding infix expression?|a+b*c+(d*e)|a) abc*+de*+|b) abc+*de*+|c) a+bc*de+*|d) abc*+(de)*+","a","Using the infix to postfix expression conversion algorithm, the corresponding postfix expression is found to be abc*+de*+.",10,
116,"Parentheses are simply ignored in the conversion of infix to postfix expression.|a) True|b) False","b","When a parenthesis is encountered, it is placed on the operator stack. When the corresponding parenthesis is encountered, the stack is popped until the other parenthesis is reached and they are discarded.",10,
117,"It is easier for a computer to process a postfix expression than an infix expression.|a) True|b) False","a","Computers can easily process a postfix expression because a postfix expression keeps track of precedence of operators.",10,
118,"What is the postfix expression for the following infix expression?|a/b^c-d|a) abc^/d-|b) ab/cd^-|c) ab/^cd-|d) abcd^/-","a","Using the infix to postfix conversion algorithm, the corresponding postfix expression for the infix expression is found to be abc^/d-.",10,
119,"Which of the following statement is incorrect with respect to infix to postfix conversion algorithm?|a) operand is always placed in the output|b) operator is placed in the stack when the stack operator has lower precedence|c) parenthesis are included in the output|d) higher and equal priority operators follow the same condition","c","Parentheses are not included in the output. They are placed in the operator stack and then discarded.",10,
120,"In infix to postfix conversion algorithm, the operators are associated from?|a) right to left|b) left to right|c) centre to left|d) centre to right","b","In infix, prefix and postfix expressions, the operators are associated from left to right and not right to left.",10,
121,"What is the corresponding postfix expression for the given infix expression?|a*(b+c)/d|a) ab*+cd/|b) ab+*cd/|c) abc*+/d|d) abc+*d/","d","Using the infix to postfix conversion algorithm, the corresponding postfix expression is obtained as abc+*d/.",10,
122,"What is the corresponding postfix expression for the given infix expression?|a+(b*c(d/e^f)*g)*h)|a) ab*cdef/^*g-h+|b) abcdef^/*g*h*+|c) abcd*^ed/g*-h*+|d) abc*de^fg/*-*h+","b","Using the infix to postfix expression conversion algorithm using stack, the corresponding postfix expression is found to be abcdef^/*g*h*+.",10,
123,"What is the correct postfix expression for the following expression?|a+b*(c^d-e)^(f+g*h)-i|a) abc^de-fg+*^*+i-|b) abcde^-fg*+*^h*+i-|c) abcd^e-fgh*+^*+i-|d) ab^-dc*+ef^gh*+i-","c","The postfix expression for the given infix expression is found to be abcd^e-fgh*+^*+i- when we use infix to postfix conversion algorithm.",10,
124,"The postfix expression abc+de/*- is equivalent to which of the following infix expression?|a) abc+-de*/|b) (a+b)-d/e*c|c) a-(b+c)*(d/e)|d) abc+*-(d/e)","c","Given postfix expression : abc+de/*- infix a(b+c)(d/e)*- a(b+c)*(d/e)- a-(b+c)*(d/e) Hence, correct choice is a-(b+c)*(d/e).",10,
125,"The prefix expression of the postfix expression AB+CD-* is __________|a) (A+B)*(C-D)|b) +AB*-CD|c) A+*BCD-|d) *+AB-CD","d","To convert from postfix to prefix, we first convert it to infix and then to prefix. postfix : AB+CD-* infix (A+B) * (C-D) So, prefix +AB*-CD, *+AB-CD. Therefore, correct choice is *+AB-CD.",10,
126,"Consider the postfix expression 4 5 6 a b 7 8 a c, where a, b, c are operators. Operator a has higher precedence over operators b and c. Operators b and c are right associative. Then, equivalent infix expression is|a) 4 a 5 6  b 7 8 a c|b) 4 a 5 c 6 b 7 a 8|c) 4 b 5 a 6 c 7 a 8|d) 4 a 5 b 6 c 7 a 8","c","Given postfix expression: 4 5 6 a b 7 8 a c (4 b (5 a 6)) (7 a 8) c (4 b (5 a 6)) c (7 a 8) So, the required infix expression is 4 b 5 a 6 c 7 a 8.",10,
127,"To convert the postfix expression into the infix expression we use stack and scan the postfix expression from left to right.|a) True|b) False","a","Stack is used to postfix expression to infix expression. And to convert we follow the following steps: (i) Scan the expression from left to right. (ii) If operand is found, push it on stack.(iii) If operator is found, the two operands are popped and the combined infix expression is formed and pushed onto the stack.",10,
128,"Which of the following is valid reverse polish expression?|a) a op b|b) op a b|c) a b op|d) both op a b and a b op","c","The postfix expression is also known as the reverse polish expression. In postfix expressions, the operators come after the operands. So, the correct expression is a b op and hence a b op is correct.",10,
129,"Which is the most appropriate data structure for reversing a word?|a) queue|b) stack|c) tree|d) graph","b","Stack is the most appropriate data structure for reversing a word because stack follows LIFO principle.",10,
130,"Operations required for reversing a word or a string using stack are push() and  pop().|a) True|b) False","a","Push operation inserts a character into the stack and pop operation pops the top of the stack.",10,
131,"What is the time complexity of reversing a word using stack algorithm?|a) O (N log N)|b) O (N2)|c) O (N)|d) O (M log N)","c","The time complexity of reversing a stack is mathematically found to be O (N) where N is the input.",10,
132,"How many stacks are required for reversing a word algorithm?|a) one|b) two|c) three|d) four","a","Only 1 stack is required for reversing a word using stack. In that stack, push and pop operations are carried out.",10,
133,"Which application of stack is used to ensure that the pair of parentheses is properly nested?|a) Balancing symbols|b) Reversing a stack|c) Conversion of an infix to postfix expression|d) Conversion of an infix to prefix expression","a","Balancing symbols application ensures that the pair of parentheses are properly nested while reversing stack reverses a stack.",10,
134,"In balancing parentheses algorithm, the string is read from?|a) right to left|b) left to right|c) center to right|d) center to left","b","Any string is read by the compiler from left to right and not from right to left.",10,
135,"Which is the most appropriate data structure for applying balancing of symbols algorithm?|a) stack|b) queue|c) tree|d) graph","a","Stack is the most appropriate data structure for balancing symbols algorithm because stack follows LIFO principle (Last In First Out).",10,
136,"Which of the following does the balancing symbols algorithm include?|a) balancing double quotes|b) balancing single quotes|c) balancing operators and brackets|d) balancing parentheses, brackets and braces","d","The balancing symbols algorithm using stack only includes balancing parentheses, brackets and braces and not any other symbols.",10,
137,"What should be done when an opening parentheses is read in a balancing symbols algorithm?|a) push it on to the stack|b) throw an error|c) ignore the parentheses|d) pop the stack","a","When an opening bracket/braces/parentheses is encountered, it is pushed on to the stack. When the corresponding end bracket/braces/parentheses is not found, throw an error.",10,
138,"If the corresponding end bracket/braces/parentheses is encountered, which of the following is done?|a) push it on to the stack|b) pop the stack|c) throw an error|d) treated as an exception","b","When the corresponding end bracket/braces/parentheses is encountered, the stack is popped. When an opening bracket/braces/parentheses is encountered, it is pushed on to the stack.",10,
139,"An error is reported when the stack is not empty at the end.|a) True|b) False","a","When the stack contains elements at the end, it means that the given string of parentheses is not balanced.",10,
140,"Is the given statement ((A+B) + [C-D]] valid with respect to balancing of symbols?|a) True|b) False","b","The given statement is invalid with respect to balancing of symbols because the last bracket does not correspond to the opening braces.",10,
141,"How many passes does the balancing symbols algorithm makes through the input?|a) one|b) two|c) three|d) four","a","The balancing symbols algorithm makes only one pass through the input since it is linear.",10,
143,"Which of the following bitwise operations will you use to set a particular bit to 0?|a) OR|b) AND|c) XOR|d) NAND","b","1 AND 0 = 0, 0 AND 0 = 0, any bit AND with 0 gives 0.",10,
144,"Which of the following bitwise operations will you use to toggle a particular bit?|a) OR|b) AND|c) XOR|d) NOT","c","1 XOR 1 = 0, 0 XOR 1 = 1, note that NOT inverts all the bits, while XOR toggles only a specified bit.",10,
145,"Which of the following is not a disadvantage of bit array?|a) Without compression, they might become sparse|b) Accessing individual bits is expensive|c) Compressing bit array to byte/word array, the machine also has to support byte/word addressing|d) Storing and Manipulating in the register set for long periods of time","d","Bit arrays allow small arrays of bits to be stored and manipulated in the register set for long periods of time with no memory accesses because of their ability to exploit bit-level parallelism, limit memory access, and maximally use the data cache, they often outperform many other data structures on practical data sets. This is an advantage of bit array. The rest are all disadvantages of bit array.",10,
146,"Which of the following is/are not applications of bit arrays?|a) Used by the Linux kernel|b) For the allocation of memory pages|c) Bloom filter|d) Implementation of Vectors and Matrices","d","Normal Arrays are used to implement vectors and matrices. Bit arrays have no prominent role. Remaining all are applications of Bit Arrays.",10,
147,"Which class in Java can be used to represent bit array?|a) BitSet|b) BitVector|c) BitArray|d) BitStream","a","The BitSet class creates a special type of array that can hold bit values.",10,
148,"Which of the following bitwise operator will you use to invert all the bits in a bit array?|a) OR|b) NOT|c) XOR|d) NAND","b","NOT operation is used to invert all the bits stored in a bit array. Eg: NOT (10110010) = 01001101.",10,
149,"Run-Length encoding is used to compress data in bit arrays.|a) True|b) False","a","A bit array stores the combinations of bit 0 and bit 1. Each bit in the bit array is independent. Run Length encoding is a data compression technique in which data are stored as single value and number of times that value repeated in the data. This compression reduces the space complexity in arrays. Bit arrays without compression require more space. Thus, we will use Run-Length encoding in most of the cases to compress data in bit arrays.",10,
150,"Bit fields and Bit arrays are same.|a) True|b) False","b","Bit field contains the number of adjacent computer locations used to store the sequence of bits to address a bit or groups of bits. Bit array is an array that stores combinations of bit 0 and bit 1. Thus, bit fields and Bit arrays are different.",10,
151,"What is meant by physical size in a dynamic array?|a) The size allocated to elements|b) The size extended to add new elements|c) The size of the underlying array at the back-end|d) The size visible to users","c","Physical size, also called array capacity is the size of the underlying array, which is the maximum size without relocation of data.",10,
152,"The number of items used by the dynamic array contents is its __________|a) Physical size|b) Capacity|c) Logical size|d) Random size","c","The number of items used by the dynamic array contents is called logical size. Physical size is the size of the underlying array, which is the maximum size without reallocation of data.",10,
153,"How will you implement dynamic arrays in Java?|a) Set|b) Map|c) HashMap|d) List","d","ArrayList is used to implement dynamic arrays in Java.",10,
154,"Which of the following is the correct syntax to declare an ArrayList in Java?|a) ArrayList al = new ArrayList();|b) ArrayList al = new ArrayList[];|c) ArrayList al() = new ArrayList();|d) ArrayList al[] = new ArrayList[];","a","This is a non-generic way of creating an ArrayList.",10,
155,"Array is divided into two parts in ____________|a) Hashed Array Tree|b) Geometric Array|c) Bounded-size dynamic array|d) Sparse Array","c","The first part stores the items of the dynamic array and the second part is reserved for new allocations.",10,
156,"Which of the following is a disadvantage of dynamic arrays?|a) Locality of reference|b) Data cache utilization|c) Random access|d) Memory leak","d","Dynamic arrays share the advantage of arrays, added to it is the dynamic addition of elements to the array. Memory can be leaked if it is not handled properly during allocation and deallocation. It is a disadvantage.",10,
157,"What is the time complexity for inserting/deleting at the beginning of the array?|a) O(1)|b) O(n)|c) O(logn)|d) O(nlogn)","b","All the other elements will have to be moved, hence O(n).",10,
158,"The size of the dynamic array is deallocated if the array size is less than _________% of the backend physical size.|a) 30|b) 40|c) 10|d) 20","a","The size of the dynamic array is decreased/deallocated if the actual size of the array is less than 30% of the backend physical size. This is used to avoid memory wastage.",10,
159,"In which of the following cases dynamic arrays are not preferred?|a) If the size of the array is unknown|b) If the size of the array changes after few iterations|c) If the memory reallocation takes more time i.e. expensive|d) If the array holds less number of elements","d","Dynamic arrays are preferred when the size of the array is unknown during memory allocation or the size changes after few iterations or the memory reallocation is expensive. If array holds less number of elements, the physical size is reduced and reduction takes more time. In that case, we can use normal arrays instead of dynamic arrays.",10,
160,"The growth factor of ArrayList in Java is _______|a) 1|b) 1.5|c) 2|d) 0","b","The growth factor of dynamic arrays (Array List) in Java is 3/2. The new array capacity is calculated as new_array_size = (old_array_size*3)/2+1.",10,
161,"In special case, the time complexity of inserting/deleting elements at the end of dynamic array is __________|a) O (n)|b) O (n1/2)|c) O (log n)|d) O (1)","a","In general, the time complexity of inserting or deleting elements at the end of dynamic array is O (1). Elements are added at reserved space of dynamic array. If this reserved space is exceeded, then the physical size of the dynamic array is reallocated and every element is copied from original array. This will take O(n) time to add new element at the end of the array.",10,
162,"When do you use a sparse array?|a) When there are unique elements in the array|b) When the array has more occurrence of zero elements|c) When the data type of elements differ|d) When elements are sorted","b","It need not necessarily be zero, it could be any default value, usually zero or null.",10,
163,"What is the difference between a normal(naive) array and a sparse array?|a) Sparse array can hold more elements than a normal array|b) Sparse array is memory efficient|c) Sparse array is dynamic|d) A naive array is more efficient","b","A naive implementation allocates space for the entire size of the array, whereas a sparse array(linked list implementation) allocates space only for the non-default values.",10,
164,"Suffix array can be created by performing __________ traversal of a suffix tree.|a) breadth-first|b) level order|c) depth-first|d) either breadth-first or level order","c","A suffix tree is a trie, which contains all the suffixes of the given string as their keys and positions in the string as their values. So, we can construct a suffix array by performing the depth-first traversal of a suffix tree.",10,
165,"Suffix array is space efficient and faster than the suffix tree.|a) True|b) Fasle","b","Suffix arrays are more space efficient than the suffix trees as they just store the original string and an array of integer. But working with suffix tree is faster than that of the suffix array.",10,
166,"If comparison based sorting algorithm is used construct the suffix array, then what will be time required to construct the suffix array?|a) O(nlogn)|b) O(n2)|c) O(n2logn)|d) O(n2) + O(logn)","c","On average comparison based sorting algorithms require O(nlogn) comparisons. But comparing a suffix takes O(n). So, overall time to construct the suffix array will be O(nlogn) * O(n) = O(n2logn).",10,
167,"LCP array and ______ is used to construct suffix tree.|a) Hash tree|b) Hash trie|c) Suffix array|d) Balanced tree","c","Suffix tree can be created using an LCP array and a suffix array. If we are given a string of length (n + 1) and its suffix array and LCP array, we can construct the suffix tree in linear time i.e in O(n) time.",10,
168,"What is the time required to locate the occurrences of a pattern P of length m in a string of length n using suffix array?|a) O(nm)|b) O(n2)|c) O(mnlogn)|d) O(mlogn)","d","Suffix arrays are used to find the occurrences of a pattern in a string. Pattern of length m will require m characters to compare, so using suffix array we can find occurrences of a pattern in the string of length n in O(mlogn) time.",10,
169,"Suffix array can be created in O(nlogn) time.|a) True|b) False","a","Suffix array can be constructed in O(n2logn) time using sorting algorithms but it is possible to build the suffix array in O(nlogn) time using prefix doubling.",10,
170,"If row-major order is used, how is the following matrix stored in memory?|a b c|d e f|g h i|a) ihgfedcba|b) abcdefghi|c) cfibehadg|d) adgbehcfi","b","It starts with the first element and continues in the same row until the end of row is reached and then proceeds with the next row. C follows row-major order.",10,
171,"Which of the following is an advantage of matrices?|a) Internal complexity|b) Searching through a matrix is complex|c) Not space efficient|d) Graph Plotting","d","Adjacency and Incidence Matrices are used to store vertices and edges of a graph. It is an advantage to plot graphs easily using matrices. But Time complexity of a matrix is O(n2) and sometimes the internal organization becomes tedious. They are all disadvantages of matrices.",10,
172,"Who coined the term Sparse Matrix?|a) Harry Markowitz|b) James Sylvester|c) Chris Messina|d) Arthur Cayley","a","Harry Markowitz coined the term Sparse Matrix. James Sylvester coined the term Matrix. Chris Messina coined the term Hashtag and Arthur Cayley developed the algebraic aspects of a matrix.",10,
173,"Is O(n) the Worst case Time Complexity for addition of two Sparse Matrix?|a) True|b) False","a","In Addition, the matrix is traversed linearly, hence it has the time complexity of O(n) where n is the number of non-zero elements in the largest matrix amongst two.",10,
174,"The matrix contains m rows and n columns. The matrix is called Sparse Matrix if ________|a) Total number of Zero elements > (m*n)/2|b) Total number of Zero elements = m + n|c) Total number of Zero elements = m/n|d) Total number of Zero elements = m-n","a","For matrix to be Sparse Matrix, it should contain Zero elements more than the non-zero elements. Total elements of the given matrix is m*n. So if Total number of Zero elements > (m*n)/2, then the matrix is called Sparse Matrix.",10,
175,"Which of the following is not the method to represent Sparse Matrix?|a) Dictionary of Keys|b) Linked List|c) Array|d) Heap","d","Heap is not used to represent Sparse Matrix while in Dictionary, rows and column numbers are used as Keys and values as Matrix entries, Linked List is used with each node of Four fields (Row, Column, Value, Next Node) (2D array is used to represent the Sparse Matrix with three fields (Row, Column, Value).",10,
176,"Is Sparse Matrix also known as Dense Matrix?|a) True|b) False","b","Sparse Matrix is a matrix with most of the elements as Zero elements while Dense Matrix is a matrix with most of the elements as Non-Zero element.",10,
177,"Which one of the following is a Special Sparse Matrix?|a) Band Matrix|b) Skew Matrix|c) Null matrix|d) Unit matrix","a","A band matrix is a sparse matrix whose non zero elements are bounded to a diagonal band, comprising the main diagonal and zero or more diagonals on either side.",10,
178,"How many inversions does a sorted array have?|a) 0|b) 1|c) 2|d) cannot be determined","a","When an array is sorted then there cannot be any inversion in the array. As the necessary condition for an inversion is arr[i]>arr[j] and i<j.",10,
179,"What is the condition for two elements arr[i] and arr[j] to form an inversion?|a) arr[i]<arr[j] |b) i < j|c) arr[i] < arr[j] and i < j|d) arr[i] > arr[j] and i < j","d","For two elements to form an inversion the necessary condition is arr[i] > arr[j] and i < j. The number of inversions in an array indicate how close or far the array is from being completely sorted.",10,
180,"Under what condition the number of inversions in an array are maximum?|a) when the array is sorted|b) when the array is reverse sorted|c) when the array is half sorted|d) depends on the given array","b","Number of inversions in an array are maximum when the given array is reverse sorted. As the necessary condition for an inversion is arr[i]>arr[j] and i<j.",10,
181,"Under what condition the number of inversions in an array are minimum?|a) when the array is sorted|b) when the array is reverse sorted|c) when the array is half sorted|d) depends on the given array","a","Number of inversions in an array are minimum when the given array is sorted. As the necessary condition for an inversion is arr[i]>arr[j] and i<j.",10,
182,"How many inversions are there in the array arr = {1,5,4,2,3}?|a) 0|b) 3|c) 4|d) 5","d","The necessary condition for an inversion is arr[i]>arr[j] and i<j. So there are 5 inversions in the array.",10,
183,"Which of the following form inversion in the array arr = {1,5,4,2}?|a) (5,4), (5,2)|b) (5,4), (5,2), (4,2)|c) (1,5), (1,4), (1,2)|d) (1,5)","b","The necessary condition for an inversion is arr[i]>arr[j] and i<j. So there are 3 inversions in the array. These are (5,4), (5,2), (4,2).",10,
184,"The time complexity of the code that determines the number of inversions in an array using merge sort is lesser than that of the code that uses loops for the same purpose.|a) true|b) false","a","The time complexity of the code that determines the number of inversions in an array using merge sort is O(n log n) which is lesser than the time complexity taken by the code that uses loops.",10,
185,"What is the time complexity of the code that uses merge sort for determining the number of inversions in an array?|a) O(n2)|b) O(n)|c) O(log n)|d) O(n log n)","d","The code of merge sort is slightly modified in order to calculate the number of inversions in an array. So the time complexity of merge sort remains unaffected and hence the time complexity is O(n log n).",10,
186,"What is the time complexity of the code that uses self balancing BST for determining the number of inversions in an array?|a) O(n2)|b) O(n)|c) O(log n)|d) O(n log n)","d","When a self balancing BST like an AVL tree is used to calculate the number of inversions in an array then the time complexity is O(n log n) as AVL insert takes O(log n) time.",10,
187,"What will be the output of the following code?|#include <iostream> using namespace std; int main() { }|a) 5 6 1 2 3 4|b) 6 5 4 3 1 2|c) 3 4 5 6 1 2|d) error","a","The given code rotates the given array by 4. It does so by using an array temp[] which stores the first d elements and then shift them to the end of the array. So the output will be 5 6 1 2 3 4.",10,
188,"What will be the time complexity of the following code?|#include <iostream> using namespace std; int main() { }|a) O(d)|b) O(n)|c) O(n2)|d) O(n*d)","b","The given code rotates an input array by d. The longest loop in the code takes n iterations so the time complexity will be O(n).",10,
189,"What will be the auxiliary space complexity of the following code?|#include <iostream> using namespace std; int main() { }|a) O(1)|b) O(n)|c) O(d)|d) O(n*d)","c","The given code rotates an input array by d. It does so by using an auxiliary array temp[] which stores first d elements of the original array. So the auxiliary space complexity will be O(d).",10,
190,"What will be the output of the following code?|#include <bits/stdc++.h> using namespace std; { } { } { } { }|a) 4 5 1 2 3|b) 3 4 5 1 2|c) 5 4 3 1 2|d) error","a","The given code rotates the input array by 3. It does so by rotating the elements one by one until the desired rotation is achieved. So the output will be 4 5 1 2 3.",10,
191,"#include <bits/stdc++.h> using namespace std; void func1(int arr[], int n) { } { } { } { }|a) O(n*d)|b) O(n)|c) O(d)|d) O(n2)","a","The given code rotates the input array by d. It does so by rotating the elements one by one until the desired rotation is achieved. Each element takes O(n) time for rotation and there are d such elements in the array. So the time complexity would be O(n*d).",10,
192,"What will be the auxiliary space complexity of the following code?|#include <bits/stdc++.h> using namespace std; void func1(int arr[], int n) { } { } { } { }|a) O(1)|b) O(n)|c) O(d)|d) O(n*d)","a","The given code rotates the input array by d. It does so by rotating the elements one by one until the desired rotation is achieved. It does not require any auxiliary array for this purpose. So the auxiliary space complexity will be O(1).",10,
193,"To rotate an array by using the algorithm of rotating its elements one by one is an in place algorithm.|a) true|b) false","a","The auxiliary space requirement of the mentioned algorithm is O(1). So it qualifies to be an in place algorithm.",10,
194,"What will be the output of the following code?|#include <bits/stdc++.h> using namespace std; void func1(int arr[], int left, int right) { { } } { } { } { }|a) 3 2 1 4 5|b) 3 4 5 1 2|c) 5 4 3 2 1|d) error","b","The given code rotates the input array by 2. It does so by applying a reversal algorithm to different segments of the array. First d elements and the rest of the array is reversed individually. Then the whole array is reversed which gives us the desired rotated array. So the output will be 3 4 5 1 2.",10,
195,"What will be the auxiliary space complexity of the code to rotate an array by using the reversal algorithm (d = number of rotations)?|a) O(1)|b) O(n)|c) O(d)|d) O(n*d)","a","The reversal algorithm for rotating an array does not require any auxiliary space. So the auxiliary space complexity will be O(1).",10,
197,"Predefined function rotate() in C++ is available under which header file?|a) math|b) stdio|c) stdlib|d) algorithm","d","The predefined function for rotating an array is rotate() in C++ which comes under the library called algorithm.",10,
198,"Which of the following algorithm to rotate an array has the maximum time complexity?|a) rotate elements one by one|b) juggling algorithm|c) reversal algorithm|d) using a temporary array","a","The maximum time complexity is required by the algorithm that rotates elements one by one. It requires O(n*d) time.",10,
199,"What is the time complexity of the juggling algorithm to rotate an array?|a) O(1)|b) O(n)|c) O(d)|d) O(n*d)","b","Time complexity of juggling algorithm is O(n). Its auxiliary space complexity is O(1).",10,
202,"When array reversal and rotation is applied to the same array then the output produced will also be the same every time.|a) true|b) false","b","Array rotation and array reversal are different operations and thus they give different outputs when applied to the same array.",10,
203,"Which of the following is the predefined function for array reversal in C++ ?|a) reverse()|b) arr_reverse()|c) array_reverse()|d) rev()","a","The predefined function for reversing an array is reverse() in C++. It is defined under the library algorithm and requires 2 arguments.",10,
204,"What will be the minimum number of jumps required to reach the end of the array arr[] ={0,1,3,6,3,6,8,5}?|a) 1|b) 2|c) 3|d) not possible to reach the end","d","Each element of the array represents the maximum number of steps that can be taken forward from that element. So as the first element here is 0 so we cannot move any further from the first element. Thus, it is not possible to reach the end of the array.",10,
208,"What will be the minimum number of jumps required to reach the end of the array arr[] = {1,2,0,0,3,6,8,5}?|a) 1|b) 2|c) 3|d) not possible to reach the end","d","Each element of the array represents the maximum number of steps that can be taken forward from that element. So we cannot move any further after reaching the second element hence it is impossible to reach the end of the array.",10,
209,"It is not possible to find the minimum number of steps to reach the end of an array in linear time.|a) true|b) false","b","It is possible to find the minimum number of steps to reach the end of an array in O(n) time complexity. So it is the fastest possible method of finding the minimum number of steps to reach the end of an array.",10,
212,": It is not possible to reach the end of an array if starting element of the array is 0.|a) true|b) false","a","If the first element of an array is 0 then it is not possible to reach the end. However, if 0 is present at other positions then we may/may not be able to reach the end.",10,
214,"Skip lists are similar to which of the following datastructure?|a) stack|b) heap|c) binary search tree|d) balanced binary search tree","d","Skip lists have the same asymptotic time complexity as balanced binary search tree. For a Balanced Binary Search Tree, we skip almost half of the nodes after one comparison with root element. The same thing done in the skip lists. Hence skip lists are similar to balanced Binary search trees.",10,
215,"What is the time complexity improvement of skip lists from linked lists in insertion and deletion?|a) O(n) to O(logn) where n is number of elements|b) O(n) to O(1) where n is number of elements|c) no change|d) O(n) to O(n2) where n is number of elements","a","In Skip list we skip some of the elements by adding more layers. In this the skip list resembles balanced binary search trees. Thus we can change the time complexity from O (n) to O (logn)5. To which datastructure are skip lists similar to in terms of time complexities in worst and best cases?|a) balanced binary search trees|b) binary search trees|c) binary trees|d) linked lists View AnswerAnswer: a Explanation: Skip lists are similar to any randomly built binary search tree. a BST is balanced because to avoid skew tree formations in case of sequential input and hence achieve O(logn) in all 3 cases. now skip lists can gurantee that O(logn) complexity for any input.",10,
216,"The nodes in a skip list may have many forward references. their number is determined|a) probabilistically|b) randomly|c) sequentially|d) orthogonally","a","The number of forward references are determined probabilistically, that is why skip list is a probabilistic algorithm.",10,
218,"How to maintain multi-level skip list properties when insertions and deletions are done?|a) design each level of a multi-level skip list with varied probabilities|b) that cannot be maintained|c) rebalancing of lists|d) reconstruction","a","For example consider a 2 level skip list. the level-2 skip list can skip one node on a average and at some places may skip 2 nodes, depending on probabilities. this ensures O(logn).",10,
219,"Is a skip list like balanced tree?|a) true|b) false","a","Skip list behaves as a balanced tree with high probability and can be commented as such because nodes with different heights are mixed up evenly.",10,
220,"Which of the following is true about the Move-To-Front Method for rearranging nodes?|a) node with highest access count is moved to head of the list|b) requires extra storage|c) may over-reward infrequently accessed nodes|d) requires a counter for each node","c","In Move-To-front Method the element which is searched is moved to the head of the list. And if a node is searched even once, it is moved to the head of the list and given maximum priority even if it is not going to be accessed frequently in the future. Such a situation is referred to as over-rewarding.",10,
221,"What technique is used in Transpose method?|a) searched node is swapped with its predecessor|b) node with highest access count is moved to head of the list|c) searched node is swapped with the head of list|d) searched nodes are rearranged based on their proximity to the head node","a","In Transpose method, if any node is searched, it is swapped with the node in front unless it is the head of the list. So, in Transpose method searched node is swapped with its predecessor.",10,
222,"The worst case running time of a linear search on the self organizing list is ____|a) O(1)|b) O(logn)|c) O(n)|d) O(n2)","c","Worst case occurs when the element is located at the very end of list. So n comparisons must be made to the locate element. So the worst case running time of linear search on self organizing list is O(n).",10,
223,"Which of the following data structure is preferred to have lesser search time when the list size is small?|a) search tree|b) sorted list|c) self organizing list|d) linked list","c","Self-organizing list is easy and simple to implement than search tree and it requires no additional space. So using self organizing list is preferred when list size is small.",10,
224,"In _____________ method, whenever a node is accessed, it might move to the head of the list if its number of accesses becomes greater than the records preceding it.|a) least recently used|b) count|c) traspose|d) exchange","b","In the count method, the number of times a node was accessed is counted and is stored in a counter variable associated with each node. Then the nodes are arranged in descending order based on their access counts. And the node with highest access count is head of the list.",10,
225,"Symbol tables during compilation of program is efficiently implemented using __________|a) a singly linked list|b) a doubly linked list|c) a self organizing list|d) an array","c","Self organizing list allows fast sequential search and it is simple to implement and requires no extra storage. Self-organizing list is used to implement the symbol table.",10,
226,"Which of the following method performs poorly when elements are accessed in sequential order?|a) count method|b) move to front method|c) transpose meth|d) ordering method","b","Move-to-front method performs poorly when the elements are accessed in sequential order, especially if that sequential order is then repeated multiple times.",10,
227,"The self organizing list improves _____|a) average access time|b) insertion|c) deletion|d) binary search","a","The self-organizing list rearranges the nodes based on the access probabilities of the nodes. So the required elements can be located efficiently. Therefore, self-organizing list is mainly used to improve the average access time.",10,
228,"What does a xor linked list have ?|a) every node stores the XOR of addresses of previous and next nodes|b) actuall memory address of next node|c) every node stores the XOR of addresses of previous and next two nodes|d) every node stores xor 0 and the current node address","a","Every node stores the XOR of addresses.",10,
229,"What does first and last nodes of a xor linked lists contain ? (let address of first and last be A and B)|a) NULL xor A and B xor NULL|b) NULL and NULL|c) A and B|d) NULL xor A and B","a","NULL xor A and B xor NULL.",10,
230,"Consider the following pseudocode of insertion in XOR list and write the approximate code snippet of it. void xor-linked-list insert(struct node **head_ref, int value) {     {     }     {     }     *head_pointer = new_node; }|a) node* next = XOR ((*head_ref)->npx,  NULL);   (*head_ref)->npx = XOR (new_node, next);|b)   (*head_ref) = XOR (new_node, next);|c) node* next = XOR ((*head_ref)->npx,  NULL);   (*head_ref)->npx->npx = XOR (new_node, next);|d) node* next = XOR ((*head_ref),  NULL);   (*head_ref)->npx = XOR (new_node, next);","a","They code for the english is node* next = XOR ((*head_ref)->npx,  NULL);   (*head_ref)->npx = XOR (new_node, next);.",10,
231,"What are implicit and explicit implementations of freelists?|a) garbage collection and new or malloc operators respectively|b) new or malloc and garbage collection respectively|c) implicit implementation is not favored|d) explicit implementation is not favored","a","Gc and new most widely known.",10,
232,"What datastructures can be used in implementing a free list?|a) only linked list|b) linked list or sort trees|c) arrays|d) trees","b","Sort trees can also be used in impelementing free lists which remaincomplex.",10,
233,"What are different ways of implementing free lists and which is simple among them?|a) best fit, first fit, worst fit, simple-first fit|b) best fit, first fit, worst fit, simple-best fit|c) best fit, first fit, worst fit, simple-worst fit|d) best fit  simple-best fit","a","The simplest form of memory management system can be called as first-fit. a device or system maintains a single list of free memory locations. When request to memory is sent, the list is searched and the first block that is large enough is returned.",10,
234,"What is buddy memory management of free lists ?|a) modified version of first fit|b) buddy allocation keeps several free lists, each one holds blocks which are of one particular size|c) modified version of best fit|d) a tree representation of free lists","b","When an allocation request is received, the list that holds blocks that are just large enough to satisfy the request are considered, and an open location is returned. If no free blocks that are smaller than two times the size that are requested are available, a larger block is split in two to satisfy the requirements.",10,
235,"How does implicit free lists(garbage collection) works in adding memory to free list ?|a) whichever comes last will be added to free list|b) whichever comes first will be added to free list|c) certain blocks cannot be used if there are no pointers to them and hence they can be freed|d) makes a probabilistic guess","c","When no pointers pointing a block that means it is useless to be in memory.",10,
236,"Assume there is a free list which contains nodes and is filled with a value if it is already assigned and the value will be the size of requested block else will be 0.   (*z <= len))          \\ too small to satisfy request {           } The above code represents what ?|a) code for first fit|b) code for best fit|c) code for worst fit|d) none of the mentioned","a","As z is start point and now from beginning we are moving and checking if we reached end and then checking size naively assigning the first block which is bigger than required size hence it is first fit.",10,
237,"How are free blocks linked together mostly and in what addressing order?|a) circular linked list and increasing addressing order|b) linked list and decreasing addressing order|c) linked list and in no addressing order|d) none of the mentioned","a","A common way is circular linked list and address are arranged in increasing order because merging would be easier which is actually a problem in buddy memory allocation.",10,
238,"What is/are the disadvantages of implementing tree using normal arrays?|a) difficulty in knowing children nodes of a node|b) difficult in finding the parent of a node|c) have to know the maximum number of nodes possible before creation of trees|d) difficult to implement","c","The size of array is fixed in normal arrays. We need to know the number of nodes in the tree before array declaration. It is the main disadvantage of using arrays to represent binary trees.",10,
239,"If the tree is not a complete binary tree then what changes can be made for easy access of children of a node in the array?|a) every node stores data saying which of its children exist in the array|b) no need of any changes continue with 2w and 2w+1, if node is at i|c) keep a seperate table telling children of a node|d) use another array parallel to the array with tree","a","Array cannot represent arbitrary shaped trees. It can only be used in case of complete trees. If every node stores data saying that which of its children exists in the array then elements can be accessed easily.",10,
240,"Why is heap implemented using array representations than tree(linked list) representations though both tree representations and heaps have same complexities? for binary heap -insert: O(log n) -delete min: O(log n) -insert: O(log n) -delete: O(log n) Then why go with array representation when both are having same values ?|a) arrays can store trees which are complete and heaps are not complete|b) lists representation takes more memory hence memory efficiency is less and go with arrays and arrays have better caching|c) lists have better caching|d) In lists insertion and deletion is difficult","b","In memory the pointer address for next node may not be adjacent or nearer to each other and also array have wonderful caching power from os and manipulating pointers is a overhead. Heap data structure is always a complete binary tree.",10,
241,"Disadvantages of linked list representation of binary trees over arrays?|a) Randomly accessing is not possible|b) Extra memory for a pointer is needed with every element in the list|c) Difficulty in deletion|d) Random access is not possible and extra memory with every element","d","Random access is not possible with linked lists.",10,
242,"Which of the following traversing algorithm is not used to traverse in a tree?|a) Post order|b) Pre order|c) Post order|d) Randomized","d","Generally, all nodes in a tree are visited by using preorder, inorder and postorder traversing algorithms.",10,
243,"The following lines talks about deleting a node in a binary tree.(the tree property must not be violated after deletion) i) from root search for the node to be deleted ii) iii) delete the node at what must be statement ii) and fill up statement iii)|a) ii)-find random node,replace with node to be deleted. iii)- delete the node|b) ii)-find node to be deleted. iii)- delete the node at found location|c) ii)-find deepest node,replace with node to be deleted. iii)- delete a node|d) ii)-find deepest node,replace with node to be deleted. iii)- delete the deepest node","d","We just replace a to be deleted node with last leaf node of a tree. this must not be done in case of BST or heaps.",10,
245,"What is the code below trying to print? void print(tree *root,tree *node) {   {   } }|a) just printing all nodes|b) not a valid logic to do any task|c) printing ancestors of a node passed as argument|d) printing nodes from leaf node to a node passed as argument","c","We are checking if left or right node is what the argument sent or else if not the case then move to left node or right node and print all nodes while searching for the argument node.",10,
246,"A binary tree is a rooted tree but not an ordered tree.|a) true|b) false","b","A binary tree is a rooted tree and also an ordered tree (i.e) every node in a binary tree has at most two children.",10,
247,"How many common operations are performed in a binary tree?|a) 1|b) 2|c) 3|d) 4","c","Three common operations are performed in a binary tree- they are insertion, deletion and traversal.",10,
248,"What is the traversal strategy used in the binary tree?|a) depth-first traversal|b) breadth-first traversal|c) random traversal|d) Priority traversal","b","Breadth first traversal, also known as level order traversal is the traversal strategy used in a binary tree. It involves visiting all the nodes at a given level.",10,
249,"How many types of insertion are performed in a binary tree?|a) 1|b) 2|c) 3|d) 4","b","Two kinds of insertion operation is performed in a binary tree- inserting a leaf node and inserting an internal node.",10,
251,"General ordered tree can be encoded into binary trees.|a) true|b) false","a","General ordered tree can be mapped into binary tree by representing them in a left-child-right-sibling way.",10,
252,"How many bits would a succinct binary tree occupy?|a) n+O(n)|b) 2n+O(n)|c) n/2|d) n","b","A succinct binary tree occupies close to minimum possible space established by lower bounds. A succinct binary tree would occupy 2n+O(n) bits.",10,
253,"The average depth of a binary tree is given as?|a) O(N)|b) O(N)|c) O(N2)|d) O(log N)","d","The average depth of a binary tree is given as O(N). In case of a binary search tree, it is O(log N).",10,
254,"How many orders of traversal are applicable to a binary tree (In General)?|a) 1|b) 4|c) 2|d) 3","d","The three orders of traversal that can be applied to a binary tree are in-order, pre-order and post order traversal.",10,
255,"If binary trees are represented in arrays, what formula can be used to locate a left child, if the node has an index i?|a) 2i+1|b) 2i+2|c) 2i|d) 4i","a","If binary trees are represented in arrays, left children are located at indices 2i+1 and right children at 2i+2.",10,
256,"Using what formula can a parent node be located in an array?|a) (i+1)/2|b) (i-1)/2|c) i/2|d) 2i/2","b","If a binary tree is represented in an array, parent nodes are found at indices (i-1)/2.",10,
257,"Construct a binary tree using the following data. The preorder traversal of a binary tree is 1, 2, 5, 3, 4. The inorder traversal of the same binary tree is 2, 5, 1, 4, 3.|a)|b)|c)|d)","d","Here, Preorder Traversal is 1, 2, 5, 3, 4. Inorder Traversal is 2, 5, 1, 4, 3. Root node of binary tree is the first node in Preorder traversal. The rough sketch of tree is:",10,
258,"For the tree below, write the post-order traversal.|b) 2, 7, 5, 2, 6, 9, 5, 11, 4|c) 2, 5, 11, 6, 7, 4, 9, 5, 2|d) 2, 7, 5, 6, 11, 2, 5, 4, 9","c","Post order traversal follows LRN(Left-Right-Node).",10,
259,"What is the possible number of binary trees that can be created with 3 nodes, giving the sequence N, M, L when traversed in post-order.|a) 15|b) 3|c) 5|d) 8","c","5 binary trees are possible and they are,",10,
260,"A full binary tree can be generated using ______|a) post-order and pre-order traversal|b) pre-order traversal|c) post-order traversal|d) in-order traversal","a","Every node in a full binary tree has either 0 or 2 children. A binary tree can be generated by two traversals if one of them is in-order. But, we can generate a full binary tree using post-order and pre-order traversals.",10,
261,"The steps for finding post-order traversal are traverse the right subtree, traverse the left subtree or visit the current node.|a) True|b) False","b","Left subtree is traversed first in post-order traversal, then the right subtree is traversed and then the output current node.",10,
262,"For a binary tree the first node visited in in-order and post-order traversal is same.|a) True|b) False","b","Consider a binary tree,",10,
263,"For the tree below, write the level-order traversal.|b) 2, 7, 5, 2, 11, 9, 6, 5, 4|c) 2, 5, 11, 6, 7, 4, 9, 5, 2|d) 2, 7, 5, 6, 11, 2, 5, 4, 9","b","Level order traversal follows a breadth first search approach.",10,
264,"The number of edges from the node to the deepest leaf is called _________ of the tree.|a) Height|b) Depth|c) Length|d) Width","a","The number of edges from the node to the deepest leaf is called height of the tree.",10,
265,"What is a full binary tree?|a) Each node has exactly zero or two children|b) Each node has exactly two children|c) All the leaves are at the same level|d) Each node has exactly one or two children","a","A full binary tree is a tree in which each node has exactly 0 or 2 children.",10,
266,"What is a complete binary tree?|a) Each node has exactly zero or two children|b) A binary tree, which is completely filled, with the possible exception of the bottom level, which is filled from right to left|c) A binary tree, which is completely filled, with the possible exception of the bottom level, which is filled from left to right|d) A tree In which all nodes have degree 2","c","A binary tree, which is completely filled, with the possible exception of the bottom level, which is filled from left to right is called complete binary tree. A Tree in which each node has exactly zero or two children is called full binary tree. A Tree in which the degree of each node is 2 except leaf nodes is called perfect binary tree.",10,
267,"Which of the following is not an advantage of trees?|a) Hierarchical structure|b) Faster search|c) Router algorithms|d) Undo/Redo operations in a notepad","d","Undo/Redo operations in a notepad is an application of stack. Hierarchical structure, Faster search, Router algorithms are advantages of trees.",10,
270,"The balance factor of a node in a binary tree is defined as _____|a) addition of heights of left and right subtrees|b) height of right subtree minus height of left subtree|c) height of left subtree minus height of right subtree|d) height of right subtree minus one","c","For a node in a binary tree, the difference between the heights of its left subtree and right subtree is known as balance factor of the node.",10,
271,"Figure below is a balanced binary tree. If a node inserted as child of the node R, how many nodes will become unbalanced?|b) 1|c) 3|d) 0","b","Only the node P will become unbalanced, with balance factor +2.",10,
272,"A binary tree is balanced if the difference between left and right subtree of every node is not more than ____|a) 1|b) 3|c) 2|d) 0","a","In a balanced binary tree the heights of two subtrees of every node never differ by more than 1.",10,
273,"Which of the following tree data structures is not a balanced binary tree?|a) AVL tree|b) Red-black tree|c) Splay tree|d) B-tree","d","All the tree data structures given in options are balanced, but B-tree can have more than two children.",10,
274,"Which of the following data structures can be efficiently implemented using height balanced binary search tree?|a) sets|b) priority queue|c) heap|d) both sets and priority queue","d","Height-Balanced binary search tree can provide an efficient implementation of sets, priority queues.",10,
275,"Two balanced binary trees are given with m and n elements respectively. They can be merged into a balanced binary search tree in ____ time.|a) O(m+n)|b) O(mn)|c) O(m)|d) O(mlog n)","a","First we store the in-order traversals of both the trees in two separate arrays and then we can merge these sorted sequences in O(m+n) time. And then we construct the balanced tree from this final sorted array.",10,
276,"Which of the following is an advantage of balanced binary search tree, like AVL tree, compared to binary heap?|a) insertion takes less time|b) deletion takes less time|c) searching takes less time|d) construction of the tree takes less time than binary heap","a","Insertion and deletion, in both the binary heap and balanced binary search tree takes O(log n). But searching in balanced binary search tree requires O(log n) while binary heap takes O(n). Construction of balanced binary search tree takes O(nlog n) time while binary heap takes O(n).",10,
277,"AVL trees are more balanced than Red-black trees.|a) True|b) False","a","AVL tree is more balanced than a Red-black tree because AVL tree has less height than Red-black tree given that both trees have the same number of elements.",10,
278,"Which process forms the randomized binary search tree?|a) Stochastic Process|b) Branching Process|c) Diffusion Process|d) Aggregation Process","a","The randomized binary search tree is formed by the stochastic process. The stochastic process or also called random process is a mathematical tool or object including random variables.",10,
279,"How many randomized binary search trees can be formed by the numbers (1, 3, 2)?|a) 2|b) 3|c) 6|d) 5","d","As there are 3 numbers (1, 3, 2) so total of 6 combinations can be formed using three numbers but Since (2, 1, 3) and (2, 3, 1) are same so in total there are 5 randomized binary search tree that can be formed.",10,
280,"What is the expected depth of a node in a randomized binary search tree?|a) log n|b) n!|c) n2|d) 2 log n + O(1)","d","The expected value of depth of a node that is for a node a, the expected value of length of path from root to node a is found to be at most 2 log n + O(1).",10,
281,"What is the longest length path for a node x in random binary search tree for the insertion process?|a) log x|b) x2|c) x!|d) 4.311 log x","d","Although it is difficult to find the length of the longest path in randomized binary search tree, but it has been found that the longest length is around 4.311 log x.",10,
282,"What is the range of  in finding the length of the longest path in a randomized binary search tree?|a) (-1, 0)|b) (1, 0)|c) (0, 5)|d) (0, 1)","d","The longest path in a randomized binary search tree, but it has been found that the longest length is around 4.311 log x for node x. This is also equal to 1/ log x where lies in the range (0, 1).",10,
283,"What is the expected number of leaves in a randomized binary search tree?|a) n + 1|b) (n + 1)/3|c) (n + 1)/2|d) n + 3","b","In a random mathematical model, the expected value of number of leaves in a randomized binary search tree is found to be exactly (n + 1)/3 using probability.",10,
284,"What is the probability of selecting a tree uniformly at random?|a) Equal to Catalan Number|b) Less Than Catalan Number|c) Greater than Catalan Number|d) Reciprocal of Catalan Number","d","Catalan number is a sequence of natural number that is used in counting problem. Hence it is found that the selecting off a tree uniformly at random is reciprocal of Catalan number.",10,
285,"Which of the following is the correct definition for a horizontal link?|a) connection between node and a child of equal levels|b) connection between two nodes|c) connection between two child nodes|d) connection between root node and leaf node","a","A horizontal link is a connection between a node and a child of equal levels.",10,
286,"How will you remove a left horizontal link in an AA-tree?|a) by performing right rotation|b) by performing left rotation|c) by deleting both the elements|d) by inserting a new element","a","A left horizontal link is removed by right rotation. A right horizontal link is removed by left rotation.",10,
287,"What are the two different operations done in an AA-Tree?|a) shift and color|b) skew and split|c) zig and zag|d) enqueue and dequeue","b","A skew removes a left horizontal link by right rotation and a split removes a right horizontal link by left rotation.",10,
288,"In an AA-tree, we process split first, followed by a skew.|a) True|b) False","b","In an AA-tree, skew is processed first followed by a split.",10,
289,"How many different shapes does maintenance of AA-Tree need to consider?|a) 7|b) 5|c) 2|d) 3","c","An AA-Tree needs to consider only two shapes unlike a red-black tree which needs to consider seven shapes of transformation.",10,
290,"What is the prime condition of AA-tree which makes it simpler than a red-black tree?|a) Only right children can be red|b) Only left children can be red|c) Right children should strictly be black|d) There should be no left children","a","The prime condition of AA-Tree is that only the right children can be red to eliminate possible restructuring cases.",10,
291,"Which of the following trees is similar to that of an AA-Tree?|a) Splay Tree|b) B+ Tree|c) AVL Tree|d) Red-Black Tree","d","AA- Tree is a small variation of Red-Black tree. AA-Trees overcome the complexity faced in performing insertion and deletion in Red-Black Trees.",10,
292,"What is the worst case analysis of an AA-Tree?|a) O(N)|b) O(log N)|c) O( N log N)|d) O(N2)","b","The worst case analysis of an AA-Tree is mathematically found to be O(log N).",10,
293,"AA-Trees makes more rotations than a red-black tree.|a) True|b) False","a","AA- trees make more rotations than a red-black tree since only two shapes are considered for an AA-Tree whereas seven shapes are considered in Red-Black trees.",10,
294,"Who is the inventor of AA-Tree?|a) Arne Anderson|b) Daniel Sleator|c) Rudolf Bayer|d) Jon Louis Bentley","a","AA-tree is invented by Arne Anderson. Daniel Sleator invented Splay Tree. Rudolf Bayer invented a Red-Black tree. Jon Louis Bentley invented K-d tree.",10,
295,"What should be the condition for the level of a left node?|a) It should be less than or equal to that of its parent|b) It should be greater than that of its parent|c) It should be strictly less than that of its parent|d) The level should be equal to one","c","The level of a left node should be strictly less than that of its parent. The level of a right node is less than or equal to that of its parent.",10,
296,"Of the following rules that are followed by an AA-tree, which of the following is incorrect?|1- Only right children can be red|2- Procedures are coded recursively|3- Instead of storing colors, the level of a node is stored|4- There should not be any left children|a) 1|b) 2|c) 3|d) 4","d","In an AA-Tree, both left and right children can be present. The only condition is that only right children can be red.",10,
297,"Why we need to a binary tree which is height balanced?|a) to avoid formation of skew trees|b) to save memory|c) to attain faster memory access|d) to simplify storing","a","In real world dealing with random values is often not possible, the probability that u are dealing with non random values(like sequential) leads to mostly skew trees, which leads to worst case. hence we make height balance by rotations.",10,
299,"To restore the AVL property after inserting a element, we start at the insertion point and move towards root of that tree. is this statement true?|a) true|b) false","a","It is interesting to note that after insertion, only the path from that point to node or only that subtrees are imbalanced interms of height.",10,
300,"Given an empty AVL tree, how would you construct AVL tree when a set of numbers are given without performing any rotations?|a) just build the tree with the given input|b) find the median of the set of elements given, make it as root and construct the tree|c) use trial and error|d) use dynamic programming to build the tree","b","Sort the given input, find the median element among them, make it as root and construct left and right subtrees with elements lesser and greater than the median element recursively. this ensures the subtrees differ only by height 1.",10,
301,"What maximum difference in heights between the leafs of a AVL tree is possible?|a) log(n) where n is the number of nodes|b) n where n is the number of nodes|c) 0 or 1|d) atmost 1","a","At every level we can form a tree with difference in height between subtrees to be atmost 1 and so there can be log(n) such levels since height of AVL tree is log(n).",10,
302,"Consider the below left-left rotation pseudo code where the node contains value pointers to left, right child nodes and a height value and Height() function returns height value stored at a particular node. What is missing?|a) Height(w-left), x-height|b) Height(w-right), x-height|c) Height(w-left), x|d) Height(w-left)","a","In the code we are trying to make the left rotation and so we need to find maximum of those two values.",10,
304,"Which of the below statements are true? i. Cartesian tree is not a height balanced tree ii. Cartesian tree of a sequence of unique numbers can be unique generated|a) both statements are true|b) only i. is true|c) only ii. is true|d) both are false","a","A height balanced cartesian tree is not possible as seen in above question. also any time a unique sequnce possess a unique cartesian tree, this can be proven through induction.",10,
305,"What is the speciality of cartesian sorting?|a) it sorts partially sorted set of data quickly|b) it considers cartesian product of elements|c) it sorts elements in less than O(logn)|d) it is a self balancing tree","a","It can sort a set which requires only some sorting or displacements. for example consider 78, 79, 80, 82, 81, 83, In this only 81 and 82 must be swaped to make it a complete sorted set, in this case cartesian sort comes to the rescue.",10,
306,"Consider a sequence of numbers to have repetitions, how a cartesian tree can be constructed in such situations without violating any rules?|a) use any tie-breaking rule between repeated elements|b) cartesian tree is impossible when repetitions are present|c) construct a max heap in such cases|d) construct a min heap in such cases","a","Consider any of the tie breaking rules, for example the element which appears first can be taken as small among the same elements and then apply cartesian tree rules.",10,
307,"What happens if we apply the below operations on an input sequence? i. construct a cartesian tree for input sequence ii. put the root element of above tree in a priority queue iii. if( priority queue is not empty) then iv. search and delete minimum value in priority queue v. add that to output vi. add cartesian tree children of above node to priority queue|a) constructs a cartesian tree|b) sorts the input sequence|c) does nothing|d) produces some random output","b","The above given steps are for sorting a cartesian tree. cartesian sort is benificial in case of partially sorted set of elements. a cartesian sort can be considered as a selection or heap sort maintaing a priority queue.",10,
308,"Cartesian trees are most suitable for?|a) searching|b) finding nth element|c) minimum range query and lowest common ancestors|d) self balancing a tree","c","In a cartesian tree minimum value can be found by finding lowest common ancestor for the extreme elements. consider 11,9,19,16 the lowest element is 9 and is a lowest common ancestor for 11 and 16. and by applying few techniques cartesian tree can be used to even find lowest common ancestors efficiently. these can be done in constant time. tree can be constructed in linear time (this is the most efficient time for any tree construction) and takes space as many elements are there.",10,
309,"A treap is a cartesian tree with _________|a) additional value, which is a priority value to the key generated randomly|b) additional value, which is a priority value to the key generated sequentially|c) additional heap rule|d) additional operations like remove a range of elements","a","A cartesian tree, if feeded with a sorted sequence will generate a straight path (or in tree terminology a skew tree). moreover a cartesian tree basing on same values from the search keys doesnot work well. so a cartesian tree with priority value in addition to search key is called treap.",10,
310,"What are the applications of weight balanced tree?|a) dynamic sets, dictionaries, sequences, maps|b) heaps|c) sorting|d) storing strings","a","They are a type of self balancing trees which are mostly used in storing key-value pairs, which is mostly used in functional programming languages. they are very useful to maintain big set of ordered objects.",10,
311,"A node of the weight balanced tree has|a) key, left and right pointers, size|b) key, value|c) key, size|d) key","a","As a weight balanced tree stores height of the subtrees, we need to use size as an additional attribute to every node. also value(for mappings) may be an optional attribute.",10,
312,"The size value of various nodes in a weight balanced tree are|a) true|b) false","a","Size of a node k is size[k] = size[k.left] + 1 + size[k.right] and based on this the weight will be given as weight[k] = size[k] + 1.",10,
313,"What are the operations that can be performed on weight balanced tree?|a) all basic operations and set intersection, set union and subset test|b) all basic operations|c) set intersection, set union and subset test|d) only insertion and deletion","a","The speciality of a weight balanced tree is a part from basic operations we can perform collective operations like set intersection, which helps in rapid prototyping in functional programming languages.",10,
314,"Consider a weight balanced tree such that, the number of nodes in the left sub tree is at least half and at most twice the number of nodes in the right sub tree. The maximum possible height (number of nodes on the path from the root to the farthest leaf) of such a tree on k nodes can be described as|a) log2 n|b) log4/3 n|c) log3 n|d) log3/2 n","d","Total number of nodes can be described by the recurrence T(n) = T((n-1)/3)) + T(2(n-1)/3) + 1 T(1) = 1. height of the tree will be H(n) = H(2/3(n-1)) + 1, H(1). drawing a recurrence tree and the cost at each level is 1 and the height will be log(3/2)n.",10,
315,"What does the below definations convey?|a) weight balanced and height balanced tree definations|b) height balanced and weight balanced tree definations|c) definations of weight balanced tree|d) definations of height balanced tree","a","They are the definations of weight and height balanceness. height balanced trees wont convey weight balanceness but opposite can be true.",10,
316,"Why do we impose restrictions like  . root property is black  . every leaf is black  . children of red node are black  . all leaves have same black|a) to get logarithm time complexity|b) to get linear time complexity|c) to get exponential time complexity|d) to get constant time complexity","a","We impose such restrictions to achieve self balancing trees with logarithmic complexities for insertions, deletions, search.",10,
317,"All the above formations are incorrect for it to be a redblack tree. then what may be the correct order?|a) 50-black root, 18-red left subtree, 100-red right subtree|b) 50-red root, 18-red left subtree, 100-red right subtree|c) 50-black root, 18-black left subtree, 100-red right subtree|d) 50-black root, 18-red left subtree, 100-black right subtree","a","Considering all the properties of red-black tree, 50 must be the black root and there are two possibilities for subtrees. one is option a and other is making all nodes of the tree to be black.",10,
318,"What are the operations that could be performed in O(logn) time complexity by red-black tree?|a) insertion, deletion, finding predecessor, successor|b) only insertion|c) only finding predecessor, successor|d) for sorting","a","We impose restrictions (refer question 2) to achieve logarithm time complexities.",10,
319,"Which of the following is an application of Red-black trees and why?|a) used to store strings efficiently|b) used to store integers efficiently|c) can be used in process schedulers, maps, sets|d) for efficient sorting","c","RB tree is used for Linux kernel in the form of completely fair scheduler process scheduling algorithm. It is used for faster insertions, retrievals.",10,
320,"When it would be optimal to prefer Red-black trees over AVL trees?|a) when there are more insertions or deletions|b) when more search is needed|c) when tree must be balanced|d) when log(nodes) time complexity is needed","a","Though both trees are balanced, when there are more insertions and deletions to make the tree balanced, AVL trees should have more rotations, it would be better to use red-black. but if more search is required AVL trees should be used.",10,
321,"Why Red-black trees are preferred over hash tables though hash tables have constant time complexity?|a) no they are not preferred|b) because of resizing issues of hash table and better ordering in redblack trees|c) because they can be implemented using trees|d) because they are balanced","b","Redblack trees have O(logn) for ordering elements in terms of finding first and next elements. also whenever table size increases or decreases in hash table you need to perform rehashing which can be very expensive in real time. also red black stores elements in sorted order rather than input order.",10,
322,"How can you save memory when storing color information in Red-Black tree?|a) using least significant bit of one of the pointers in the node for color information|b) using another array with colors of each node|c) storing color information in the node structure|d) using negative and positive numbering","a","The node pointers can be used to store color with the help of significant bits. the exceptions of this method are in languages like java where pointers are not used this may not work.",10,
323,"When to choose Red-Black tree, AVL tree and B-trees?|a) many inserts, many searches and when managing more items respectively|b) many searches, when managing more items respectively and many inserts respectively|c) sorting, sorting and retrieval respectively|d) retrieval, sorting and retrieval respectively","a","Red black when frequent inserts and deletes, AVL when less frequent inserts and deletes, B-tree when using paging from a slow storage device.",10,
327,"Which data structure is used to maintain a dynamic forest using a link or cut operation?|a) Top Tree|b) Array|c) Linked List|d) Stack","a","Top tree data structure is used to maintain a dynamic forest using link or cut operations. Top tree is a type of data structure which is based on unrooted dynamic binary tree and is used to solve path related problems.",10,
328,"If A  B (A and B are two clusters) is a singleton set then it is a Merge able cluster.|a) True|b) False","a","If A  B is a singleton set where A and B are two clusters, that is there are only one node that is common between the clusters then they are known as Merge able cluster.",10,
329,"Is Top tree used for maintaining Dynamic set of trees called forest.|a) True|b) False","a","Top tree data structure is used to maintain a dynamic forest using link or cut operations. Top tree is a type of data structure which is based on unrooted dynamic binary tree and is used to solve path related problems.",10,
330,"What is the time complexity for the initialization of top tree?|a) O (n)|b) O (n2)|c) O (log n)|d) O (n!)","a","Generally, trees have weight on its edges. Also there is one to one correspondence of the edges with the top trees. Therefore, top trees can be initialized in O (n) time.",10,
